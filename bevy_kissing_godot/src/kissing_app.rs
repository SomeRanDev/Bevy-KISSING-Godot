use crate::{kissing_component::kissing_component_registry::KissingComponentRegistry, prelude::*};

use std::collections::BTreeMap;

use bevy::prelude::*;
use godot::prelude::*;

// -------------------------
// * Top-Level Macro Calls *
// -------------------------

include!(concat!(env!("OUT_DIR"), "/add_components_for_node.rs"));

// -----------
// * Structs *
// -----------

/// Contains implementations for the "App" node generated by BevyðŸ’‹Godot.
///
/// Most of the code is kept here to prevent it from being implemented within a macro.
pub struct KissingApp {
	app: Option<App>,
	node_id_to_bevy_entity: BTreeMap<InstanceId, Entity>,
}

impl Default for KissingApp {
	fn default() -> Self {
		Self {
			app: None,
			node_id_to_bevy_entity: BTreeMap::new(),
		}
	}
}

/// `KissingApp` public responses.
///
/// This implementation contains all the functions that execute in response to Godot events.
impl KissingApp {
	/// Returns mutable reference to Bevy app instance.
	pub fn get_app_mut(&mut self) -> &mut App {
		self.app.as_mut().unwrap()
	}

	/// Called immediately before the `#[kiss_bevy(_)]` function implemented by the user.
	pub fn pre_ready(&mut self) {
		let mut app = bevy::prelude::App::new();
		app.add_plugins(crate::prelude::KissingCorePlugin);
		self.app = app.into();
	}

	/// Called immediately after the `#[kiss_bevy(_)]` function implemented by the user.
	pub fn post_ready(&mut self, tree: Gd<SceneTree>) {
		self.setup_scene_tree(tree);

		if let Some(app) = self.app.as_mut() {
			app.world_mut().run_schedule(bevy::prelude::Startup);
		}
	}

	/// Called every `_process` of the user's Bevy app node.
	pub fn process(&mut self, delta: f64) {
		let Some(app) = self.app.as_mut() else { return };
		app.world_mut().resource_mut::<ProcessDelta>().0 = delta;
		app.world_mut().run_schedule(Process);
		app.world_mut().clear_trackers();
	}

	/// Called every `_physics_process` of the user's Bevy app node.
	pub fn physics_process(&mut self, delta: f64) {
		let Some(app) = self.app.as_mut() else { return };
		app.world_mut().resource_mut::<PhysicsProcessDelta>().0 = delta;
		app.world_mut().run_schedule(PhysicsProcess);
	}

	/// Connected to `SceneTree`'s `node_added` signal.
	pub fn on_node_added(&mut self, node_added: Gd<Node>) {
		self.setup_node(&node_added);
	}

	/// Connected to `SceneTree`'s `node_removed` signal.
	pub fn on_node_removed(&mut self, node_removed: Gd<Node>) {
		let Some(app) = self.app.as_mut() else { return };

		if let Some(entity) = self
			.node_id_to_bevy_entity
			.remove(&node_removed.instance_id())
		{
			app.world_mut().despawn(entity);
		}
	}
}

/// `KissingApp` node set ups.
///
/// This implementation contains functions for initializing Godot nodes and stuff.
impl KissingApp {
	/// Called in the `_ready` for the App node to set up entities for all nodes.
	fn setup_scene_tree(&mut self, scene_tree: Gd<SceneTree>) {
		let Some(scene) = scene_tree.get_current_scene() else {
			godot_warn!(
				"Could not get [current_scene] when setting up [SceneTree] during make-out session between Bevy and Godot."
			);
			return;
		};

		self.setup_scene(scene);
	}

	/// Set up the scene.
	fn setup_scene(&mut self, mut scene: Gd<Node>) {
		self.setup_node_children(&mut scene);
	}

	/// Set up a node's children recusively.
	fn setup_node_children(&mut self, parent_node: &Gd<Node>) {
		for i in 0..parent_node.get_child_count() {
			let Some(child_node) = parent_node.get_child(i) else {
				continue;
			};

			self.setup_node(&child_node);
			self.setup_node_children(&child_node);
		}
	}

	/// Set up a node for the first time.
	fn setup_node(&mut self, node: &Gd<Node>) {
		let Some(world) = self.app.as_mut().map(|a| a.world_mut()) else {
			return;
		};

		let mut entity = if let Some(entity) = add_components_for_node(world, &node) {
			entity
		} else {
			world.spawn_empty()
		};

		entity.insert(GodotNodeId::new(&node));

		let entity_id = entity.id();

		if let Ok(mut ready_trait) = node.clone().try_dynify::<dyn BevyEntityReady>() {
			ready_trait.dyn_bind_mut().bevy_entity_ready(entity);
		}

		KissingComponentRegistry::apply_kissing_components(&node, world, entity_id);

		self.node_id_to_bevy_entity
			.insert(node.instance_id(), entity_id);
	}
}
