use crate::kissing_component::kissing_component_registry::KissingComponentRegistry;
use crate::prelude::*;
use crate::resources::gd_tracker::{AllNodes, AllResources};

use std::collections::BTreeMap;
use std::mem;

use bevy::prelude::*;
use godot::prelude::*;

// -------------------------
// * Top-Level Macro Calls *
// -------------------------

include!(concat!(env!("OUT_DIR"), "/add_components_for_node.rs"));

// -----------------
// * TreeResponder *
// -----------------

/// The node that receives and stores info from `SceneTree` events.
#[derive(GodotClass)]
#[class(init, base = Node)]
pub struct TreeResponder {
	base: Base<Node>,

	added_nodes: Vec<Gd<Node>>,
	removed_nodes: Vec<InstanceId>,
}

impl TreeResponder {
	pub fn on_node_added(&mut self, node_added: Gd<Node>) {
		self.added_nodes.push(node_added);
	}

	pub fn on_node_removed(&mut self, node_removed: Gd<Node>) {
		self.removed_nodes.push(node_removed.instance_id());
	}
}

inventory::submit! {
	crate::kissing_node::kissing_node::KissingNode::new(
		"TreeResponder",
		|world| crate::kissing_node::kissing_node::KissingNode::create_entity_with_godot_node_class_components::<TreeResponder>(world),
	)
}

// --------------
// * KissingApp *
// --------------

/// Contains implementations for the "App" node generated by BevyðŸ’‹Godot.
///
/// Most of the code is kept here to prevent it from being implemented within a macro.
pub struct KissingApp {
	app: Option<App>,
	tree_responder: Option<Gd<TreeResponder>>,
	node_id_to_bevy_entity: BTreeMap<InstanceId, Entity>,
}

impl Default for KissingApp {
	fn default() -> Self {
		Self {
			app: None,
			tree_responder: None,
			node_id_to_bevy_entity: BTreeMap::new(),
		}
	}
}

/// `KissingApp` public responses.
///
/// This implementation contains all the functions that execute in response to Godot events.
impl KissingApp {
	/// Returns mutable reference to Bevy app instance.
	pub fn get_app_mut(&mut self) -> &mut App {
		self.app.as_mut().unwrap()
	}

	/// Sets the `app` to `None` to end any Bevy processing.
	pub fn clear_app(&mut self) {
		self.app = None;
	}

	/// Called immediately before the `#[kiss_bevy(_)]` function implemented by the user.
	pub fn pre_ready(&mut self) {
		let mut app = bevy::prelude::App::new();
		app.add_plugins(crate::prelude::KissingCorePlugin);
		app.insert_non_send_resource(AllNodes::default());
		app.insert_non_send_resource(AllResources::default());
		self.app = app.into();
	}

	/// Called immediately after the `#[kiss_bevy(_)]` function implemented by the user.
	pub fn post_ready(&mut self, app_node: Gd<Node>, tree: Gd<SceneTree>) {
		self.setup_scene_tree(tree.clone());
		self.init_tree_responder(app_node, tree);

		if let Some(app) = self.app.as_mut() {
			app.world_mut().run_schedule(bevy::prelude::Startup);
		}
	}

	/// Creates `TreeResponder` and connect it to the `SceneTree`'s signals.
	fn init_tree_responder(&mut self, mut app_node: Gd<Node>, tree: Gd<SceneTree>) {
		let mut tree_responder = TreeResponder::new_alloc();
		tree_responder.set_name("TreeResponder");
		app_node.call_deferred("add_child", &[tree_responder.to_variant()]);
		//app_node.add_child(&tree_responder);

		tree.signals()
			.node_added()
			.connect_other(&tree_responder, TreeResponder::on_node_added);
		tree.signals()
			.node_removed()
			.connect_other(&tree_responder, TreeResponder::on_node_removed);

		self.tree_responder = tree_responder.into();
	}

	/// Called every `_process` of the user's Bevy app node.
	pub fn process(&mut self, delta: f64) {
		let Some(app) = self.app.as_mut() else { return };
		app.world_mut().resource_mut::<ProcessDelta>().0 = delta;
		app.world_mut().run_schedule(Process);
		app.world_mut().clear_trackers();
		self.handle_tree_responder_events();
	}

	/// Called every `_physics_process` of the user's Bevy app node.
	pub fn physics_process(&mut self, delta: f64) {
		let Some(app) = self.app.as_mut() else { return };
		app.world_mut().resource_mut::<PhysicsProcessDelta>().0 = delta;
		app.world_mut().run_schedule(PhysicsProcess);
		self.handle_tree_responder_events();
	}

	/// Handle any changes that occured from `TreeResponder` receiving `SceneTree` events.
	fn handle_tree_responder_events(&mut self) {
		let Some(tree_responder) = self.tree_responder.as_mut() else {
			return;
		};
		let added_nodes = mem::take(&mut tree_responder.bind_mut().added_nodes);
		let removed_nodes = mem::take(&mut tree_responder.bind_mut().removed_nodes);
		for n in added_nodes {
			self.on_node_added(n);
		}
		for n in removed_nodes {
			self.on_node_removed(n);
		}
	}

	/// Connected to `SceneTree`'s `node_added` signal.
	pub fn on_node_added(&mut self, node_added: Gd<Node>) {
		self.setup_node(&node_added);
	}

	/// Connected to `SceneTree`'s `node_removed` signal.
	pub fn on_node_removed(&mut self, node_removed: InstanceId) {
		let Some(app) = self.app.as_mut() else { return };

		app.world_mut()
			.non_send_resource_mut::<AllNodes>()
			.remove(&node_removed);

		if let Some(entity) = self.node_id_to_bevy_entity.remove(&node_removed) {
			app.world_mut().despawn(entity);
		}
	}
}

/// `KissingApp` node set ups.
///
/// This implementation contains functions for initializing Godot nodes and stuff.
impl KissingApp {
	/// Called in the `_ready` for the App node to set up entities for all nodes.
	fn setup_scene_tree(&mut self, scene_tree: Gd<SceneTree>) {
		let Some(scene) = scene_tree.get_current_scene() else {
			godot_warn!(
				"Could not get [current_scene] when setting up [SceneTree] during make-out session between Bevy and Godot."
			);
			return;
		};

		self.setup_scene(scene);
	}

	/// Set up the scene.
	fn setup_scene(&mut self, mut scene: Gd<Node>) {
		self.setup_node_children(&mut scene);
	}

	/// Set up a node's children recusively.
	fn setup_node_children(&mut self, parent_node: &Gd<Node>) {
		for i in 0..parent_node.get_child_count() {
			let Some(child_node) = parent_node.get_child(i) else {
				continue;
			};

			self.setup_node(&child_node);
			self.setup_node_children(&child_node);
		}
	}

	/// Set up a node for the first time.
	fn setup_node(&mut self, node: &Gd<Node>) {
		let Some(world) = self.app.as_mut().map(|a| a.world_mut()) else {
			return;
		};

		let id = {
			let mut all_nodes = world.non_send_resource_mut::<AllNodes>();
			all_nodes.as_mut().register(node.clone())
		};

		let mut entity = if let Some(entity) = add_components_for_node(world, &node) {
			entity
		} else {
			world.spawn_empty()
		};

		entity.insert(id);

		let entity_id = entity.id();

		if let Ok(mut ready_trait) = node.clone().try_dynify::<dyn BevyEntityReady>() {
			ready_trait.dyn_bind_mut().bevy_entity_ready(entity);
		}

		KissingComponentRegistry::apply_kissing_components(&node, world, entity_id);

		self.node_id_to_bevy_entity
			.insert(node.instance_id(), entity_id);
	}
}
